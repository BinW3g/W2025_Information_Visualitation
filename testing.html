<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>D3 Map - Country Filter</title>
  <style>
    body {
      margin: 0;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      height: 100vh;
      background: #f0f0f0;
      font-family: sans-serif;
    }

    #controls {
      margin-bottom: 10px;
      z-index: 10;
    }

    select {
      padding: 5px 10px;
      font-size: 16px;
      border-radius: 4px;
      border: 1px solid #ccc;
    }

    svg {
      background-color: #aadaff;
      border: 1px solid #ccc;
      box-shadow: 0 4px 6px rgba(0,0,0,0.1);
    }

    path {
      fill: #69b3a2;
      stroke: #ffffff;
      stroke-width: 0.5px;
      vector-effect: non-scaling-stroke;
    }

    path:hover {
      fill: #4e8a7c;
      cursor: pointer;
    }
  </style>
  <script src="https://d3js.org/d3.v7.min.js"></script>
</head>
<body>

<div id="controls">
  <label for="countrySelect">Select Country: </label>
  <select id="countrySelect">
    <option value="all">Show All</option>
  </select>
</div>

<svg id="myMap"></svg>

<script>
  const width = 800;
  const height = 600;

  const svg = d3.select("#myMap")

  const mapGroup = svg.append("g");

  // Zoom Behavior
  const zoom = d3.zoom()
  .scaleExtent([1, 8])
  .on("zoom", (event) => {
    mapGroup.attr("transform", event.transform);
  });

  svg.call(zoom);

  const projection = d3.geoMercator();
  const pathGenerator = d3.geoPath().projection(projection);

  let allFeatures = [];

  d3.json("./data/countries_filtered.json").then(function(geoData) {

    // --- WINDING FIX ---
    geoData.features.forEach(function(feature) {
      if (feature.geometry.type === "Polygon") {
        feature.geometry.coordinates.forEach(ring => ring.reverse());
      }
      else if (feature.geometry.type === "MultiPolygon") {
        feature.geometry.coordinates.forEach(polygon => {
          polygon.forEach(ring => ring.reverse());
        });
      }
    });

    allFeatures = geoData.features;

    // --- 1. EXTRACT UNIQUE COUNTRIES (ADMIN) ---
    // Instead of mapping 'name_en' (provinces), we map 'admin' (countries)
    const uniqueCountries = Array.from(new Set(allFeatures.map(d => d.properties.admin))).sort();

    // Populate Dropdown
    const select = d3.select("#countrySelect");

    select.selectAll("option.country")
    .data(uniqueCountries)
    .enter()
    .append("option")
    .attr("class", "country")
    .attr("value", d => d)
    .text(d => d); // Displays "Argentina", "Australia", etc.

    // Handle Change
    select.on("change", function() {
      const selectedCountry = d3.select(this).property("value");
      updateMap(selectedCountry);
    });

    // Initial Draw
    updateMap("all");

  }).catch(error => console.error(error));


  function updateMap(selectedCountry) {
    let filteredData;

    // --- 2. FILTER BY ADMIN PROPERTY ---
    if (selectedCountry === "all") {
      filteredData = allFeatures;
    } else {
      // Keep only features where properties.admin matches the selection
      filteredData = allFeatures.filter(d => d.properties.admin === selectedCountry);
    }

    // Create a temporary FeatureCollection to calculate the zoom box
    const collection = { type: "FeatureCollection", features: filteredData };

    // Fit the map to the new collection
    projection.fitSize([width, height], collection);

    // Reset zoom to default before drawing
    svg.transition().duration(750).call(
        zoom.transform,
        d3.zoomIdentity
    );

    // Draw Paths
    mapGroup.selectAll("path")
    .data(filteredData, d => d.properties.name_en) // Use province name as ID
    .join("path")
    .attr("d", pathGenerator)
    .append("title")
    .text(d => d.properties.name_en); // Tooltip still shows Province name
  }
</script>
</body>
</html>